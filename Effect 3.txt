/*
	Ian Melvin
	Effect 3
	Purpose: Create a full screen psychedelic event

*/

float waves(vec3 position, float time){
    float flt = 0.0;

    flt += length(sin(position+time));
    flt = sin(flt * length(position.xy) + time) * 0.5 + 0.5;
    return flt;
}

//Takes in a bool and a float, returns a vec3 corresponding to rgb
vec3 colorLines(int inCircle, vec2 coord, float time, vec2 fragCoord)
{
    float size = 20.0;
    
    if(inCircle == 1)
	{
        vec2 position = floor(coord / size);
    	float modulus = mod(position.x + position.y, 2.0);
    
 		if (modulus == 0.0)
    	{
       		return 0.5 + 0.5*cos(8.0*time+vec3(0,2,4));
    	}
    	else
    	{
    		return 0.5 + 0.5*cos(8.0*time-vec3(4,2,0));
    	}
    }
    else if(inCircle == 2)
	{
        vec2 position = floor(coord / size);
    	float modulus = mod(position.x + position.y, 2.0);
    
 		if (modulus == 0.0)
    	{
            return 0.5 + 0.5*cos(8.0*time-vec3(2,3,1));
    	}
    	else
    	{
    		return 0.5 + 0.5*cos(8.0*time+vec3(1,3,2));
    	}
    }
    else
    {
        vec2 position = floor(fragCoord / size);
    	float modulus = mod(60.0, position.x + position.y);
        float modulus2 = mod(60.0, position.x - position.y);
    
 		if (modulus == 0.0)
    	{
       		return vec3(1.0, 0.0, 0.5);
    	}
        else if (modulus2 == 0.0)
        {
        	return vec3(.25, 0.9, 0.6);
        }
    	else
    	{
    		return 0.5 + 0.5*cos(time-vec3(2.4,1.6,6));
    	}
    }
}

float leng(float radius, float dist, float time)
{
    float len = 0.0;
    
    len = mod(time + 0.0, 5.0) * radius;
    
    len = length(dist) - len; //Based on line 17 of "A Simple Circle" by jonobr1 https://www.shadertoy.com/view/XsjGDt
    
    return len;
}


//Takes in two vec2 and a float to calculate the distance between a point and the center, 
//and make sure the value is within the circle returns a vec4
vec4 circle(vec2 coord1, vec2 center, float radius[7], float time)
{
    radius[6] = leng(radius[6], coord1-center, time);
    
    
    
    if(radius[6] <= 0.0)
    {
       return vec4(colorLines(2, coord1 - center, time, coord1), time*1.0);
    }
    else if(radius[5] <= 0.0)
    {
       return vec4(colorLines(1, coord1 - center, time, coord1), time*1.0);
    }
    else if(radius[4] <= 0.0)
    {
       return vec4(colorLines(2, coord1 - center, time, coord1), time*1.0);
    }
    else if(radius[3] <= 0.0)
    {
       return vec4(colorLines(1, coord1 - center, time, coord1), time*1.0);
    }
    else if(radius[2] <= 0.0)
    {
       return vec4(colorLines(2, coord1 - center, time, coord1), time*1.0);
    }
    else if(radius[1] <= 0.0)
    {
        return vec4(colorLines(1, coord1 - center, time, coord1), time*1.0);
    }
    else if(radius[0] <= 0.0)
    {
        return vec4(colorLines(2, coord1 - center, time, coord1), time*1.0);
    }
    else
    {
       return vec4(colorLines(3, coord1 - center, time, coord1), time*1.0);   
    }
    
}

//Takes in a vec2 for a coordinates and outputes a color
void mainImage(out vec4 fragColor, in vec2 fragCoord)
{   
    float radiusArray[7] = float[7](40.0, 40.0, 30.0, 20.0, 15.0, 10.0, 5.0);
    vec2 center = iMouse.xy;
    
    fragCoord.xy -= center;    
	vec2 uv = fragCoord.xy / iResolution.x*20.0;
    
    
    vec4 bkgcolor = vec4(1.0);
    float f = 0.0;
    float d = length(uv);
    
    for(float i = 0.0; i<6.0; i++){
    	f += waves(vec3(uv.x,uv.y,i*0.7),iTime); 
    }
    bkgcolor.r = f;
    bkgcolor.a =1.0;
	fragColor = bkgcolor * circle(fragCoord, uv, radiusArray, iTime);
}